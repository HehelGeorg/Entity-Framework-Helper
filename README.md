# Что такое EF-helper?
**EF-Helper** -  это библиотека, созданная для того, чтобы упростить и стандартизировать работу с Entity Framework Core в корпоративных и личных проектах:
* **Pattrens-part**: Она предлагает готовые, базовые реализации известных паттернов, таких как **Specification** и **Generic Repository**, устраняя их традиционные недостатки, а также подход, используемый **Спецификацию**, позволяет обоготатить доменный уровень.

* **EF-Extensions-part**: Предлагает инкапсулированные методы для использования больших возможностей PostgreSQL в EF, предоставляя инкапсулированные методы расширения для FLuentAPI, а также методы для использования продвинутых возможностей EF, к примеру, секционирование, материализованные представления и т.д.

* **EF-scripts-encapsulation-part**: Предоставляет инкапсулированные методы создания готовой новомодной архитектуры PostgreSQL и БД, а также низкоуровневые инкапсулированные методы по обращению к специфическим возможностям БД и PostgreSQL.

Разрабатываться части будут в той же последовательности, что они были названы.




**На данный момент**
**Готов к использванию**:
-
**Производится**
- Patterns-Part







# В чём суть и какие проблемы решают данные решение?
* Во-первых, реализует абстрактные и , в общем, базовые части известных паттернов работы с ORM для дальнейшего удобного переиспользования в корпоративных средах или собственных решениях от мала до велика, просто определяя конкретную часть паттерна(а ввиду использования **Спецификации** конкретные моменты явно граничат и очень легко реализуются, отчего потребность в наиболее явном разделении этих двух моментов возрастает, все-таки **Спецификация** очень гибкий и очень расширяемый паттерн, чья базовая реализация существенно больше чем, скажем, **Репозитория**, но оттого и более насыщена плюшками в виде, скажем, соединения двух запросов по "И", "ИЛИ" и прочих логических операторов),


  а именно такие как
    
    
    * паттерн **Specification**, а также
    
    
    
    * паттерн **Generic Of Repository**, базирующийся на специфкации, устраняя тем самым все существенные недостатки оригинальной реализации:
       
       
       * **Масштабируемость**: По мере роста проекта по необходимости появляется потребность в написании бесконечных Get{Подставьте сюда любое слово}() для более удобного, инкапсулированного и переиспользуемого доступа к данным, но надо ли говорить, что такой подход быстро убивает ту изящность паттерна Репозиторий, благодаря которому мы и можем видеть его в бесчисленных коропртаивных или собственных программных решениях
       
       
       * **Удобство и идиоматичность**: Вместо того, чтобы изощиряться в разных более конкретных вариациях для дальнейшего переиспользования кода, делая фактически **Репозиторий** над **Репозиторием**, который предоставляет сам dbcontext, разбрасываться абстракциям, подобно фантикам, а также явно накладывать слишком большие обязательстьва на **Репозиторий**, куда лучшим решением будет сместить всё бремя конкретного запроса на **Спецификацию**, да и просто более удобного и гибкого способа составления запросов, элегантно пользуясь возможностями **Expression**, а также  умением **Entity Framework** интепретировать его в запрос.


      Ни к чему писать огромную иерархию **Репозиториев** , куда, как по мне, будет лучше, если **Репозиторий** ограничиться стандартными 4 методами CRUD, а всё, что могло бы сподвигнуть нас написать кучу **Репозиториев** пропадает посредством того, что **Спецификация** удобно решает проблемы переиспользуемости, инкапсулированности создания запрсов и удобочитаемости, оставляя на репозиторий обязанность быть связующим звеном с инфраструктурой, скажем, используя разных стартегий кэширования, совершая обращения к разным ORM и прочие инфраструктурные моменты.
      Бремя запроса таким образом целиком на **Специфкации**
 
